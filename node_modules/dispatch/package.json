{
  "name": "dispatch",
  "description": "A regular expression URL dispatcher for Connect",
  "main": "./index",
  "author": {
    "name": "Caolan McMahon"
  },
  "version": "0.2.0",
  "repository": {
    "type": "git",
    "url": "http://github.com/caolan/dispatch.git"
  },
  "bugs": {
    "url": "http://github.com/caolan/dispatch/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/caolan/dispatch/raw/master/LICENSE"
    }
  ],
  "readme": "# Dispatch\n\nA really simple URL dispatcher for\n[Connect](http://github.com/senchalabs/connect). Allows arbitrarily nested\nregular expressions for matching URLs and calling an associated function.\n\n    var Connect = require('connect'),\n        dispatch = require('dispatch');\n\n    Connect.createServer(\n        dispatch({\n            '/about': function(req, res, next){\n                ...\n            },\n            '/user/:id': function(req, res, next, id){\n                ...\n            },\n            '/user/posts': function(req, res, next){\n                ...\n            },\n            '/user/posts/(\\\\w+)': function(req, res, next, post){\n                ...\n            }\n        })\n    );\n\nDispatch can be used with a straight-forward object literal containing view\nfunctions keyed by URL. As you can see from the last URL in the list, captured\ngroups are passed to the matching function as an argument.\n\nYou can also use :named parameters in a URL, which is just a more readable way\nof capturing ([^\\/]+). Named parameters are passed to the matched function in\nthe same way as normal regular expression groups.\n\nSo far so predictable. However, it is also possible to nest these objects as\nyou see fit:\n\n    Connect.createServer(\n        dispatch({\n            '/about': function(req, res, next){ ...  },\n            '/user': {\n                '/': function(req, res, next){ ...  },\n                '/posts': function(req, res, next){ ...  },\n                '/posts/(\\\\w+)': function(req, res, next, post){ ...  }\n            }\n        })\n    );\n\nThis helps you tidy up the structure to make it more readable. It also makes\nrenaming higher-level parts of the path much simpler. If we wanted to change\n'user' to 'member', we'd now only have to do that once. Another advantage of\nbeing able to nest groups of URLs is mounting reusable apps in your site tree.\nLet's assume that 'user' is actually provided by another module:\n\n    Connect.createServer(\n        dispatch({\n            '/about': function(req, res, next){ ... },\n            '/user': require('./user').urls\n        })\n    );\n\nEasy! A really lightweight and flexible URL dispatcher that just does the\nobvious.\n\nIts also possible to define methods for URLs:\n\n    Connect.createServer(\n        dispatch({\n            '/user': {\n                'GET /item': function(req, res, next){ ... },\n                'POST /item': function(req, res, next){ ... },\n            }\n        })\n    );\n\nJust prefix the URL with the http method in uppercase followed by whitespace\nand then the path you want to match against. Nested URLs always match the last\nmethod defined in the tree. Because of this, you can use the following style for\nmatching request methods, if you prefer:\n\n    dispatch({\n        '/test': {\n            GET: function (req, res, next) {\n                ...\n            },\n            POST: function (req, res, next) {\n                ...\n            }\n        }\n    })\n\nA couple of implementation points:\n\n1. The regular expressions automatically have '^' and '$' added to the pattern\n   at the start and end or the URL.\n2. Only the first match is called, subsequent matches for a URL will not be\n   called.\n3. If there are no matches, the request is passed to the next handler in the\n   Connect middleware chain.\n\nI like to combine this with [quip](http://github.com/caolan/quip) for rapid\nprototyping and just getting my ideas down in code:\n\n    var Connect = require('connect'),\n        quip = require('quip'),\n        dispatch = require('dispatch');\n\n    var server = Connect.createServer(\n        quip(),\n        dispatch({\n            '/': function(req, res, next){\n                res.text('hello world!');\n            },\n            '/api': function(req, res, next){\n                res.json({hello: 'world'});\n            }\n        })\n    );\n\n    server.listen(8080);\n\nHave fun!\n",
  "readmeFilename": "README.md",
  "_id": "dispatch@0.2.0",
  "dist": {
    "shasum": "546dc1694f5b0df0221d84dc04602420eefc715f"
  },
  "_from": "dispatch"
}
